### 1. RDD 구조와 특징

- 대량의 데이터를 요소로 가지는 분산 컬렉션
- 거대한 배열과 리스트등의 자료구조
- 내부는 파티션이라는 단위로 나뉨
- 스파크에서는 파티션이 분산처리 단위임
- RDD를 파티션 단위로 여러 머신에서 처리하므로 큰 데이터를 다룰 수 있음
- 사용자는 HDFS 등의 분산 파일시스템을 RDD로 로드하고, RDD를 가공하는 형식으로 대량의 데이터를 분산처리
  - 가공을 변환(transformation)
  - 내용에 따라 액션(action)처리를 적용

------

## 2. RDD 다루기

##### 변환(transformation)

- RDD를 가공하고 그 결과로 새로운 RDD를 얻는 처리
- 변환은 두 종류로 구분할 수 있음
  - 변환전의 RDD가 가지는 요소를, 같은 RDD의 다른 요소들과 관계없이 처리
    - filter - 요소를 필터링
    - map - 각 요소에 동일한 처리를 적용
    - flatmap- - 각 요소에 동일한 처리를 적용하고 여러개의 요소 생성
    - zip - 파티션 수가 같고 요소도 같은 두 개의 RDD를 조합해 한쪽을 KEY 다른한쪽은 VALUE를 가지는 쌍을 만듦
  - 변환전의 RDD가 가지는 요소를, 같은 RDD의 다른 요소들과 함께 처리
    이때 같은 키를 가지는 요소가 전부 같은 파티션에 있어야 함
    이 때, 서로다른 파티션에 있는 같은 키를 가지는 요소의 자리 변경을 셔플이라함
    - reduceByKey - 같은 키를 가지는 요소를 집약처리(aggregation)
      (A, 1) (B, 1) (A, 1) (C, 1) (A, 1) (A, 1) -> (A, 3) (B, 1) (C, 1)
    - join - 같은 키를 가지는 요소끼리 조인
      (A, 1) (B, 2) (A, 1_1) (B, 2_1) (A, 1_2)  -> (A, 1, 1_1) (A, 1, 1_2) (B, 2, 2_1)

##### 액션(action)

- 변환이 RDD로 부터 다른 RDD를 얻는 '데이터 가공' 이였다면
- 액션은 RDD 내용을 바탕으로 원하는 결과를 얻는 조작임
  - saveAsTextFile - RDD의 내용을 파일로 출력
  - count - RDD의 요소 수를 셈

-------

# 3. 스파크 분산처리 환경

##### 클러스터 환경 개요

- 스파크는 여러 머신으로 구성된 클러스터 환경에서의 동작을 전제로 한 분산처리 플랫폼
- 클러스터 환경에서 처리를 시행하는 일반적인 시스템은 클러스터 내의 계산 리소스를 관리하는 기능이 필요함
- 여기서는 그러한 기능을 제공하는 시스템을 '클러스터 관리 시스템'이라 함
- 스파크는 세 종류의 클러스터 관리 시스템을 지원
  - YARN
    하둡의 클러스터 관리 시스템
    분산처리를 위한 범용 클러스터 관리 시스템으로 설계되어 스파크 이외의 분산처리 프레임워크를 돌릴 수 있음
    분산처리의 데이터 소스로 하둡의 분산파일시스템인 HDFS 이용할때, YARN을 같이 사용하면 데이터 지역성(처리에 필요한 데이터가 보존된 머신에 처리가 할당)이 고려되어 효율적인 I/O 처리가 이루어짐
  - Mesos
    YARN과 마찬가지로 범용 클러스터 관리 시스템
    처리에 할당하는 CPU 코어 수의 분배를 바꿀 수 있는 세세한 제어가 가능
  - Spark Standalone
    스파크에 번들되는 전용 클러스터 관리 시스템
    별도의 클러스터 관리 시스템 없이 편리하게 이용 가능
- 클러스터 관리 시스템 하에서 각 머신은 **마스터 노드** 또는 **워커 노드**로 동작
  - 마스터 노드 - 클러스터 내의 계산 리소스를 집중하며 관리 역할을 담당
  - 워커 노드 - CPU 코어와 메모리 등의 계산 리소스를 제공하고 할당된 처리를 실행\
- 분산처리 프로세스
  - 어플리케이션 배포와 계산 리소스 요구
    - RDD 생성과 일련의 변환으로 구성된 스파크 어플리케이션을 클라이언트가 클러스터에 배포(deploy)함
    - 클라이언트는 배포와 동시에 익스큐터(executor)의 스펙을 지정함. 
    - 익스큐터란 워커 노드에서 구동하여 스파크 어플리케이션을 분산처리하는 프로세스를 뜻함
    - 익스큐터의 스펙으로는 CPU 코어수의 할당량과 메모리 할당량, 클러스터 내에서 구동할 익스큐터 수를 지정 가능
  - 클러스터 내 계산 리소스 확보
    - 클러스터에 어플리케이션이 배포되면 마스터 노드는 각 워커 노드의 이용 가능한 리소스양과 클라이언트가 요청하는 익스큐터의 스펙을 고려하여 하나 이상의 워커 노드에 익스큐터의 구동을 요구함
  - 드라이버 프로그램 구동
    - 클러스터 내에 리소스가 확보됨과 동시에 '드라이버 프로그램'이 구동됨
    - 드라이버 프로그램이란 사용자에 의해 정의되는 스파크 어플리케이션의 엔트리 포인트(C나 자바의 함수와 같은 실행 포인트)가 되는 프로그램
    - 사용자가 기술한 RDD의 생성 및 변환 로직을 이용해 어플리케이션을 제어하는 역할을 담당
  - 태스크 스케쥴링과 실행
    - 스파크 어플리케이션은 RDD 생성부터 액션 적용까지 통틀어 잡(job)이라는 단위로 처리함
    - 드라이버 프로그램에 포함되는 스케줄러에 의해 익스큐터가 처리 가능한 태스크(task)라는 단위로 분할되며 그 실행이 스케쥴링됨
    - 태스크는 파티션 단위로 데이터를 로드하고 변환과 액션을 적용하는 처리 단위
    - 익스큐터가 각 태스크를 처리함으로써 RDD 전체가 분산처리 됨

##### 드라이버 프로그램(코드말하는듯)

- 스파크 어플리케이션 개발시, 사용자는 드라이버 프로그램에 RDD의 생성과 변환, 액션의 로직등을 기술

  ```scala
  val textRDD = sc.textFile("/huge-text")
  // RDD의 각 요소에 변환을 적용
  val mappedRDD = textRDD.map(text => someFunction(text))
  val filteredRDD = textRDD.filter(processText => filterFunction(processText))
  ...
  // RDD에 액션을 적용하고, 원래의 텍스트 파일을 가공한 결과를 저장
  processedRDD.saveAsTextFile("result")
  ```

- RDD 지연평가(lazy evaluation)
  크고 많은 데이터를 드라이버 프로그램에서 RDD를 생성하거나 변환할수 있는 요인
  위 코드에서 RDD에 데이터를 로드하거나 변환 및 액션을 실행하는것 처럼 보이지만 선언한 것에 불과함
  실제 처리는 잡 형태로 클러스터에서 실행되고 실행 시점은 드라이버 프로그램에서 액션의 작용이 선언될때까지 지연됨

##### 태스크 스케쥴링

- RDD의 생성과 로드는 지연 평가로 인해 클러스터를 처리할 때 데이터를 가진 상태가 됨(인스턴스화)
- 드라이버 프로그램에서 생성된 RDD에는 태스크 작성과 스케쥴링에 필요한 정보가 포함
- 스케쥴링 정보
  - RDD의 본래 데이터 정보, 또는 변환하기 전의 RDD
  - RDD 생성에 필요한 데이터를 어떤 식으로 로드해야 하는가? 또는, RDD에 어떤 변환을 실행해야 하는가?
  - 변환 후 RDD 요소의 형
  - 변환 후 RDD 파티션의 수
  - 파티셔너(셔플을 발생시키는 변환 후의 RDD의 경우)
  - RDD가 영속화(presistence)되었는가?
- RDD에 대한 액션 적용이 선언되면, 해당 드라이버 프로그램에서 동작하는 스케쥴러가 이 정보를 바탕으로 변환의 전체적인 흐름을 해석함
- 익스큐터는 네트워크 통신과 I/O 부하가 가능한 작아지도록 태스크를 구성하는 등 스케쥴링에 도움을 줌

변환의 전체적인 흐름을 해석한 결과 로드할 데이터의 위치를 알게 되면, 데이터의 지역성을 고려해 데이터에 물리적으로 가까운 곳에서 실행되는 익스큐터를 할당할 수 있음. RDD가 클러스터 환경에서 영속화되면 해당 RDD를 인스턴스화 하는 과정을 생략하도록 스케쥴링할 수 있음

또한 변환에 의해 셔플이 필요해질지를 파악하여 네트워크 통신 부하를 최소한으로 억제할수도 있음. 셔플은 여러 파티션에 걸쳐 요소들을 재배치하며, 태스크는 데이터 로드와 일련의 변환 및 액션의 적용을 파티션 단위로 실행하는 처리 단위인 만큼, 셔플 전후의 RDD를 구성하는 파티션은 각각 다른 태스크로 처리해야 함

태스크는 익스큐터에서 처리되므로, 셔플을 실행한다는 것은 곧 익스큐터 간의 다대다 네트워크 통신이 필요해져, 어플리케이션 전체를 통틀어 비교적 부하가 높은 처리가 된다는 의미임. 변환이 셔플을 발행하시키지 않을 경우에는 변환 전후의 파티션끼리 동일한 태스크에 포함시킬 수 있으므로네트워크 통신을 억제할 수 있음. 이처럼 태스크를 짤 수 있는 것도 지연평가 덕분

이처럼 태스크에는 동일한 파티션의 연속 변환이 포함되기도 하는데 파티션에 데이터를 로드하는 태스크부터 차례로 실행되도록 스케쥴링함으로써, RDD 생성을 시작으로 일련의 변환과 액션 적용까지 클러스터 환경에서 실행할 수 있음. 태스크가 할당된 익스큐터는 해당 태스크에 포함된 첫 파티션부터 마지막 파티션까지 순서대로 인스턴스화해 처리함

스파크에서는 익스큐터에 장애가 발생하는 등의 이유로 태스크 실행에 실패하면 다른 익스큐터로 재실행됨. 이 경우에도 태스크 내용을 바탕으로 파티션을 순서대로 인스턴스화해 처리. 스파크는 이것을 재계산 이라고함

RDD는 불변(한번 생성된 인스턴트는 임의로 값을 바꿀수도 바뀌지도 않기때문에 참조 전용 객체의 특성을 갖음)하므로, 재계산에 의해 동일한 변환이나 액션이 적용되더라도 같은 경과를 얻을 수 있음

##### RDD 영속화(결과를 데이터로 만들어버린다는 뜻인듯)

- 익스큐터는 태스크 처리를 끝낼 때, 처리 과정에서 생성된 파티션 인스턴스를 영속화함
- 스파크에서는 RDD가 다음 조건 중 어느 하나라도 만족하면 영속화함
  - 셔플이 발생하는 변환을 실행하기 직전의 RDD
  - 사용자에 의해서 명시적으로 영속화가 선언된 RDD
- 영속화가 안됬을때는 작업을 처음부터 실행
- 영속화가 됬을때는 영속화된 지점부터 실행